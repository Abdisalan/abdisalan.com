<html>
<head>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h2>Table of Contents</h2>
    <ul>
        <li><a href="index.html">Introduction</a></li>
        <li><b>Multifinger BST Model</b></li>
        <li><a href="performance.html">Notable BST Performance Improvements</a></li>
        <li><a href="notable_bsts.html">Some BST Data Structures</a></li>
        <li><a href="results.html">Results</a></li>
        <li><a href="theory.html">Theory & Method</a></li>
        <li><a href="future.html">Future Work</a></li>
    </ul>

    <h1>Multifinger-BST Model</h1>
    <section>
        <h2>Regular BST</h2>
        <img src="images/Single.JPG">
        <p>
        The traditional BST model of a set of elements is defined as:
        </p>
        <ul>
            <li>A single rooted tree of n nodes</li>
            <li>Each node holds a value which we call a key</li>
            <li>Each node stores 3 pointers -- to its parent, left and right child</li>
            <li>The key stored in the left tree is smaller than the parent's key</li>
            <li>The key stored in the right tree is larger than the parent's key</li>
        </ul>
        More importantly, and what we focus on is that to implement searches in this tree,
        there is a single "finger" pointed to a node in the tree.
    </section>

    <section>
        <h2>The Multifinger-BST Model</h2>
        <img src="images/multi.JPG">
        <p>
        Identical to the traditional BST model above, but we have a constant number of fingers
        all initially at the root of the tree. These additional fingers allow for various improvements
        when searching for nodes.
        </p>
    </section>





</body>
</html>
