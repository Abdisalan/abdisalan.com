<html>
<head>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h2>Table of Contents</h2>
    <ul>
        <li><a href="index.html">Introduction</a></li>
        <li><a href="bst_models.html">Multifinger BST Model</a></li>
        <li><b>Definitions and Models</b></li>
        <li><a href="notable_bsts.html">Some BST Data Structures</a></li>
        <li><a href="results.html">Results</a></li>
        <li><a href="theory.html">Theory & Method</a></li>
        <li><a href="future.html">Future Work</a></li>
    </ul>

    <h1>Definitions and Models</h1>
    <p>
        This list of definitions will be important when dicussing
        the significance of our algorithm and its ability to combine performance bounds from many BSTs. I start
        off with an important distinction between online and offline BSTs. All these definitions can be found on page 2
        of the the publication.
    </p>
    <br>

    <section>
        <h3>Distinction: Online BST vs. Offline BST</h3>
        <p>
            <b>For a sequence of seaches in a BST:</b>
        </p>

        <p>An <i>offline</i> BST is able to perform the searches as a function of the the entire access sequence.
           In other words, the BST is constructed with knowledge of the entire sequence and the best possible performing tree is made.
        </p>

        <p>An <i>online</i> BST is able to perform each searches as a function of all the searches that came before.
            The BST is initially constructed with no knowledge of the sequence, then is able to adjust the BST as
            each access is made.
        </p>
    </section>


    <section>
        <h3>Working Set Bound</h3>
        <p>If a BST data structure holds the working set bound, then each access to <i>x</i> is done
            in <i>O(log w(x))</i> time where <i>w(x)</i> is the number of elements accessed since the last access to
            <i>x</i>.  This is a great improvment when the many of the same element are accessed many times.
        </p>
        <h4> Example </h4>
        <img src="images/working_set.JPG">
        <p>Here 23 was accessed first, then 72, then 50. Each time an element was accessed, it was moved the root of the tree. Because 72 was accessed recently,
            it is much further up in the tree and can be found quicker.</p>
    </section>

    <section>
        <h3>Static and Dynamic Finger Bound</h3>
        <p>Remember those <a href="bst_models.html">multifinger BSTs?</a> Here are some performance improvments from having multiplefingers.</p>
        <p>The static finger bound requires that each access <i>x</i> is executed in <i>O(log d(f,x))</i> amortized time where <i>d(f,x)</i> is
            the number of keys between any fixed finger <i>f</i> and <i>x</i>. The number of keys between the finger and x is defined as the number of values
            within the tree with <i>f</i> as the root and and <i>x</i> as a leaf.
        </p>
        <h4>Example</h4>
        <img src="images/static_optimality.JPG">
        <p>Because there is a finger at 12, 14 can be access much faster than from the root.</p>
        <p>
           The dynamic finger bound which requires that each access <i>x</i> is executed in <i>O(log d(y, x))</i> amortized time where <i>y</i>
            is the previous item in the access sequence.
        </p>
    </section>
    <br>
    <br>

    <h2>Useful definitions</h2>

    <section>
        <h3>C-competitive Binary Search Tree</h3>
        <p>For an access sequence <i>X</i> there exists an offline BST that can perform it optimally.
            The number of unit cost of operations performed by this BST is <i>OPT(X)</i>. An <i>online</i>
            BST is C-competitive if it can perform <i>X</i> in at most <i>C*OPT(X)</i>. An online BST that is
            O(1)-Competitive is called <i>dynamically optimal</i>.
        </p>
    </section>

    <section>
        <h3>Unified Bound</h3>
        <p>
            The unified bound is a combination of both the dynamic finger bound and the working set bound.
        </p>
    </section>


    <section>
        <h3>Static Optimality Bound</h3>
        <p>
            The static optimality bound requires that any access sequence is executed within a constant factor of the time it would take to
            execute it on the best static tree for that sequence.
        </p>
    </section>


</body>
</html>
